<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ideas — Resonance</title>
  <link rel="icon" type="image/png" href="papermint_logo.png" />
  <link rel="stylesheet" href="styles.css" />
  <script src="theme.js"></script>
</head>
<body>
  <div class="dashboard">

    <!-- ===== TOP BAR ===== -->
    <header class="dashboard-topbar">
      <div class="topbar-left">
        <button type="button" class="btn btn-ghost sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle menu">☰</button>
        <a href="index.html" class="topbar-logo" style="text-decoration:none"><img src="papermint_logo.png" alt="" class="logo-icon" /> resonance</a>
      </div>
      <div class="topbar-right">
        <div class="avatar-dropdown">
          <button type="button" class="avatar avatar-btn" id="avatar" onclick="toggleAvatarMenu()" title="Account">?</button>
          <div class="avatar-menu" id="avatar-menu">
            <a href="settings.html" class="avatar-menu-item">⚙ Preferences</a>
            <button type="button" class="avatar-menu-item" onclick="handleLogout()">Log out</button>
          </div>
        </div>
      </div>
    </header>

    <!-- ===== SIDEBAR (mirrors dashboard) ===== -->
    <aside class="dashboard-sidebar" id="dashboard-sidebar">
      <div class="sidebar-item" onclick="window.location='dashboard.html'">
        <span class="icon">+</span> New search
      </div>
      <div class="sidebar-label">Previous topics</div>
      <div id="sidebar-topics"><!-- filled by JS --></div>
      <div class="sidebar-spacer"></div>
      <div class="sidebar-label">Explore</div>
      <div class="sidebar-item active">
        <span class="icon">✦</span> Top Ideas
      </div>
      <div class="sidebar-label">Settings</div>
      <div class="sidebar-item" onclick="window.location='settings.html'">
        <span class="icon">⚙</span> Preferences
      </div>
    </aside>

    <!-- ===== MAIN ===== -->
    <main class="dashboard-main" id="main-content">
      <div class="greeting">
        <h1>Top Ideas</h1>
        <p>The most promising research ideas found across all your past searches.</p>
      </div>

      <div class="ideas-container" id="ideas-container">
        <!-- Blobs injected by JS -->
        <div id="ideas-loading" class="loading-indicator" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)">
          <div class="loading-spinner"></div>
          <span>Loading ideas…</span>
        </div>
      </div>

      <!-- Topic legend -->
      <div id="ideas-legend" class="ideas-legend" style="display:none"></div>

      <!-- Tooltip (follows mouse) -->
      <div class="idea-tooltip" id="idea-tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-body"></p>
      </div>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase.js"></script>
  <script>
    let allIdeas = [];

    function toggleAvatarMenu() {
      document.getElementById('avatar-menu').classList.toggle('open');
    }
    document.addEventListener('click', function(e) {
      const d = document.querySelector('.avatar-dropdown');
      if (d && !d.contains(e.target)) document.getElementById('avatar-menu').classList.remove('open');
    });
    async function handleLogout() {
      await authSignOut();
      window.location.href = 'index.html';
    }

    function toggleSidebar() {
      const dash = document.querySelector('.dashboard');
      if (dash) dash.classList.toggle('sidebar-collapsed');
    }

    (async () => {
      const user = await requireAuth();
      if (!user) return;

      const { data: profile } = await getProfile(user.id);
      const name = profile?.first_name || user.email?.split('@')[0] || '?';
      document.getElementById('avatar').textContent = name.charAt(0).toUpperCase();

      // Populate sidebar topics
      await loadSidebarTopics();

      await loadIdeas();
    })();

    async function loadSidebarTopics() {
      try {
        const topics = await fetchTopics();
        const container = document.getElementById('sidebar-topics');
        if (!container) return;
        if (!topics || topics.length === 0) {
          container.innerHTML = '<div class="sidebar-empty">No topics yet</div>';
          return;
        }
        container.innerHTML = topics.map(t =>
          `<div class="sidebar-item" onclick="window.location='dashboard.html#topic=${encodeURIComponent(t.topic)}'">
            <span class="icon">◇</span> ${t.topic}
          </div>`
        ).join('');
      } catch (e) {
        console.warn('Failed to load sidebar topics:', e);
      }
    }

    async function loadIdeas() {
      const user = await getUser();
      if (!user) return;

      // Fetch all debates with joined paper data for this user, sorted by confidence
      let query = sb.from('debates')
        .select('*, papers(*)')
        .order('confidence', { ascending: false });
      query = query.eq('user_id', user.id);

      const { data, error } = await query;
      if (error) {
        console.error('loadIdeas:', error);
        return;
      }

      // Filter to PROMISING and INTERESTING only, limit to 10 to prevent clutter
      allIdeas = (data || []).filter(d =>
        d.verdict === 'PROMISING' || d.verdict === 'INTERESTING'
      ).slice(0, 10);

      document.getElementById('ideas-loading').style.display = 'none';

      if (allIdeas.length === 0) {
        const container = document.getElementById('ideas-container');
        container.innerHTML = `
          <div style="text-align:center; padding:80px 24px; color:var(--text-tertiary);">
            <p style="font-size:1.1rem; margin-bottom:8px;">No promising ideas yet</p>
            <p>Run some searches from the <a href="dashboard.html" style="text-decoration:underline">dashboard</a> to see results here.</p>
          </div>`;
        return;
      }

      const ideasForApi = allIdeas.map(d => ({
        id: String(d.id),
        paper_name: (d.papers && d.papers.paper_name) || d.topic,
        topic: d.topic,
        one_liner: d.one_liner
      }));
      let edges = [];
      try {
        const res = await fetchMindmapEdges(ideasForApi);
        edges = res.edges || [];
      } catch (e) {
        console.warn('Mindmap edges failed:', e);
      }
      renderMindmap(edges);
      renderLegend();
    }

    function renderLegend() {
      const el = document.getElementById('ideas-legend');
      if (!el) return;
      // Collect unique topics already colored
      const topicSet = [...new Set(allIdeas.map(d => d.topic || 'Unknown'))];
      if (topicSet.length < 2) { el.style.display = 'none'; return; }
      el.style.display = 'flex';
      el.innerHTML = topicSet.map(t =>
        `<span class="legend-chip"><span class="legend-dot" style="background:${topicColor(t)}"></span>${t}</span>`
      ).join('');
    }

    // ── Mindmap state ──
    let nodes = [];          // [{id, x, y, vx, vy, el, idea}]
    let mindmapEdges = [];
    let dragNode = null;
    let didDrag = false;
    let dragOffset = { x: 0, y: 0 };
    let physicsRAF = null;

    const MIN_NODE = 40;          // smallest circle (0% confidence)
    const MAX_NODE = 160;         // biggest circle (100% confidence)
    const DAMPING = 0.85;
    const REPEL_FORCE = 8000;
    const REPEL_RANGE = 3.0;     // repel when closer than N × combined radii
    const EDGE_SPRING = 0.003;
    const CENTER_PULL = 0.0005;  // very gentle — let user placements stick

    // Deterministic color per topic string
    const _topicColors = {};
    const PALETTE = [
      '#6366f1', '#ec4899', '#f59e0b', '#10b981', '#3b82f6',
      '#8b5cf6', '#ef4444', '#14b8a6', '#f97316', '#06b6d4',
      '#a855f7', '#22c55e', '#e11d48', '#0ea5e9', '#d946ef',
      '#84cc16', '#f43f5e', '#2dd4bf', '#fb923c', '#818cf8',
    ];
    let _colorIdx = 0;
    function topicColor(topic) {
      if (!topic) return PALETTE[0];
      if (!_topicColors[topic]) {
        _topicColors[topic] = PALETTE[_colorIdx % PALETTE.length];
        _colorIdx++;
      }
      return _topicColors[topic];
    }
    function nodeSize(confidence) {
      const t = Math.max(0, Math.min(1, confidence || 0));
      // Exponential curve for more dramatic size difference
      const curved = t * t;
      return MIN_NODE + curved * (MAX_NODE - MIN_NODE);
    }

    function renderMindmap(edges) {
      mindmapEdges = edges;
      if (physicsRAF) cancelAnimationFrame(physicsRAF);

      const container = document.getElementById('ideas-container');
      container.innerHTML = '';
      const W = container.offsetWidth || 900;
      const H = Math.max(container.offsetHeight || 500, 500);
      const centerX = W / 2;
      const centerY = H / 2;
      const radius = Math.min(W, H) * 0.42;
      const N = allIdeas.length;

      // ── SVG for edges ──
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'mindmap-svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      container.appendChild(svg);

      const gEdges = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      gEdges.setAttribute('class', 'edges');
      svg.appendChild(gEdges);

      // ── Create node objects ──
      nodes = [];
      allIdeas.forEach((idea, i) => {
        const id = String(idea.id);
        const paper = idea.papers || {};
        const conf = idea.confidence || 0;
        const topic = idea.topic || '';
        const sz = nodeSize(conf);
        const color = topicColor(topic);

        // Spread in a circle initially
        const angle = (2 * Math.PI * i) / N - Math.PI / 2;
        const x = centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 20;
        const y = centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 20;

        // DOM element
        const el = document.createElement('div');
        el.className = 'idea-node idea-blob';
        el.dataset.id = id;
        el.style.width = sz + 'px';
        el.style.height = sz + 'px';

        const title = paper.paper_name || topic || 'Unknown';
        const shortTitle = title.length > 32 ? title.slice(0, 29) + '…' : title;
        el.innerHTML =
          `<div class="blob-circle" style="background:${color}"><span class="blob-verdict">${Math.round(conf * 100)}%</span></div>` +
          `<span class="blob-title">${shortTitle}</span>`;

        // Events
        el.addEventListener('mouseenter', e => showTooltip(e, idea));
        el.addEventListener('mousemove', moveTooltip);
        el.addEventListener('mouseleave', hideTooltip);
        el.addEventListener('click', () => {
          if (!didDrag) {
            window.open(`dashboard.html#topic=${encodeURIComponent(topic)}`, '_blank');
          }
        });
        el.addEventListener('mousedown', (e) => {
          e.preventDefault();
          didDrag = false;
          dragNode = id;
          const nd = nodes.find(n => n.id === id);
          const rect = container.getBoundingClientRect();
          dragOffset.x = (e.clientX - rect.left) - (nd ? nd.x : x);
          dragOffset.y = (e.clientY - rect.top) - (nd ? nd.y : y);
        });

        container.appendChild(el);

        nodes.push({ id, x, y, vx: 0, vy: 0, el, idea, size: sz, pinned: false });
      });

      // ── Mouse handlers for dragging (attach once) ──
      if (!renderMindmap._listenersAttached) {
        renderMindmap._listenersAttached = true;
        document.addEventListener('mousemove', (e) => {
          if (!dragNode) return;
          didDrag = true;
          const container2 = document.getElementById('ideas-container');
          if (!container2) return;
          const rect = container2.getBoundingClientRect();
          const nd = nodes.find(n => n.id === dragNode);
          if (!nd) return;
          nd.x = (e.clientX - rect.left) - dragOffset.x;
          nd.y = (e.clientY - rect.top) - dragOffset.y;
          nd.vx = 0;
          nd.vy = 0;
        });
        document.addEventListener('mouseup', () => {
          if (dragNode && didDrag) {
            // Pin the node so physics won't move it back
            const nd = nodes.find(n => n.id === dragNode);
            if (nd) nd.pinned = true;
          }
          dragNode = null;
        });
      }

      // ── Edge lookup for spring forces ──
      const edgePairs = new Set();
      mindmapEdges.forEach(e => {
        edgePairs.add(`${e.from_id}:${e.to_id}`);
        edgePairs.add(`${e.to_id}:${e.from_id}`);
      });

      // ── Physics loop ──
      function tick() {
        for (let i = 0; i < nodes.length; i++) {
          const a = nodes[i];
          // Skip nodes being dragged or pinned by the user
          if (a.id === dragNode || a.pinned) continue;
          const aHalf = a.size / 2;

          // Gentle pull toward center (very weak so nodes stay spread)
          a.vx += (centerX - a.x) * CENTER_PULL;
          a.vy += (centerY - a.y) * CENTER_PULL;

          // Repel from other nodes — wider range so they stay well apart
          for (let j = 0; j < nodes.length; j++) {
            if (i === j) continue;
            const b = nodes[j];
            let dx = a.x - b.x;
            let dy = a.y - b.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const minDist = (a.size + b.size) * REPEL_RANGE;
            if (dist < minDist) {
              const force = REPEL_FORCE / (dist * dist);
              a.vx += (dx / dist) * force;
              a.vy += (dy / dist) * force;
            }
          }

          // Spring toward connected nodes (gentler)
          for (let j = 0; j < nodes.length; j++) {
            if (i === j) continue;
            const b = nodes[j];
            if (!edgePairs.has(`${a.id}:${b.id}`)) continue;
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const ideal = (a.size + b.size) * 2.5;
            a.vx += dx * EDGE_SPRING * (dist - ideal) / dist;
            a.vy += dy * EDGE_SPRING * (dist - ideal) / dist;
          }

          // Dampen
          a.vx *= DAMPING;
          a.vy *= DAMPING;
          a.x += a.vx;
          a.y += a.vy;

          // Bounce off walls
          if (a.x < aHalf)      { a.x = aHalf;      a.vx = Math.abs(a.vx) * 0.5; }
          if (a.x > W - aHalf)  { a.x = W - aHalf;  a.vx = -Math.abs(a.vx) * 0.5; }
          if (a.y < aHalf)      { a.y = aHalf;      a.vy = Math.abs(a.vy) * 0.5; }
          if (a.y > H - aHalf)  { a.y = H - aHalf;  a.vy = -Math.abs(a.vy) * 0.5; }
        }

        // Update DOM positions
        nodes.forEach(n => {
          const h = n.size / 2;
          n.el.style.left = (n.x - h) + 'px';
          n.el.style.top = (n.y - h) + 'px';
        });

        // Redraw SVG edges
        redrawEdges();
        physicsRAF = requestAnimationFrame(tick);
      }

      function redrawEdges() {
        gEdges.innerHTML = '';
        mindmapEdges.forEach(e => {
          const from = nodes.find(n => n.id === String(e.from_id));
          const to = nodes.find(n => n.id === String(e.to_id));
          if (!from || !to) return;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', from.x);
          line.setAttribute('y1', from.y);
          line.setAttribute('x2', to.x);
          line.setAttribute('y2', to.y);
          line.setAttribute('class', 'mindmap-edge');
          gEdges.appendChild(line);
          const midX = (from.x + to.x) / 2;
          const midY = (from.y + to.y) / 2;
          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', midX);
          label.setAttribute('y', midY - 4);
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('class', 'mindmap-edge-label');
          label.textContent = e.label || '';
          gEdges.appendChild(label);
        });
      }

      physicsRAF = requestAnimationFrame(tick);
    }

    function showTooltip(e, idea) {
      const paper = idea.papers || {};
      const tooltip = document.getElementById('idea-tooltip');
      document.getElementById('tooltip-title').textContent =
        paper.paper_name || idea.topic || 'Unknown';

      const lines = [];
      if (idea.one_liner) lines.push(idea.one_liner);
      if (idea.topic) lines.push(`Topic: ${idea.topic}`);
      lines.push(`Verdict: ${idea.verdict} · ${Math.round((idea.confidence||0)*100)}% confidence`);
      if (idea.topicality != null) lines.push(`Topicality: ${Math.round(idea.topicality*100)}%`);
      document.getElementById('tooltip-body').textContent = lines.join('\n');

      tooltip.classList.add('visible');
      moveTooltip(e);
    }

    function moveTooltip(e) {
      const tooltip = document.getElementById('idea-tooltip');
      tooltip.style.left = (e.clientX + 16) + 'px';
      tooltip.style.top = (e.clientY + 16) + 'px';
    }

    function hideTooltip() {
      document.getElementById('idea-tooltip').classList.remove('visible');
    }

    window.addEventListener('resize', () => {
      if (allIdeas.length > 0) renderMindmap(mindmapEdges);
    });
  </script>
</body>
</html>

